
import java.util.*;
import java.io.*;

public class SortingRoutines extends javax.swing.JFrame {

    //Global Variable Declaration
    boolean sizePicked = false, directionPicked = false, ascending = true, shifted = true;
    int size = 0;
    int loopCounter = 0, compareCounter = 0, shiftCounter = 0;
    long time = 0;
    String output, stats;
    int[] origin1 = null;
    int[] origin2 = null;
    int[] origin3 = null;
    int[] s1 = null;
    int[] s2 = null;
    int[] s3 = null;

    public SortingRoutines() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        title = new javax.swing.JLabel();
        info1 = new javax.swing.JLabel();
        button10 = new javax.swing.JRadioButton();
        button100 = new javax.swing.JRadioButton();
        button1000 = new javax.swing.JRadioButton();
        button5000 = new javax.swing.JRadioButton();
        sortButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        originOutput = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        sortedOutput = new javax.swing.JTextArea();
        info2 = new javax.swing.JLabel();
        buttonAscend = new javax.swing.JRadioButton();
        buttonDescend = new javax.swing.JRadioButton();
        errorLabel = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        statOutput = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        title.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        title.setText("Sorting Efficiencies");

        info1.setText("Select number of objects to sort:");

        button10.setText("10");
        button10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                button10ActionPerformed(evt);
            }
        });

        button100.setText("100");
        button100.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                button100ActionPerformed(evt);
            }
        });

        button1000.setText("1000");
        button1000.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                button1000ActionPerformed(evt);
            }
        });

        button5000.setText("5000");
        button5000.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                button5000ActionPerformed(evt);
            }
        });

        sortButton.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        sortButton.setText("Sort Objects");
        sortButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sortButtonActionPerformed(evt);
            }
        });

        jScrollPane1.setAutoscrolls(true);

        originOutput.setEditable(false);
        originOutput.setColumns(20);
        originOutput.setRows(5);
        jScrollPane1.setViewportView(originOutput);

        jScrollPane2.setAutoscrolls(true);

        sortedOutput.setEditable(false);
        sortedOutput.setColumns(20);
        sortedOutput.setRows(5);
        jScrollPane2.setViewportView(sortedOutput);

        info2.setText("Numbers should:");

        buttonAscend.setText("Ascend");
        buttonAscend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonAscendActionPerformed(evt);
            }
        });

        buttonDescend.setText("Descend");
        buttonDescend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonDescendActionPerformed(evt);
            }
        });

        errorLabel.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        errorLabel.setForeground(new java.awt.Color(153, 0, 0));

        statOutput.setEditable(false);
        statOutput.setColumns(20);
        statOutput.setRows(5);
        jScrollPane3.setViewportView(statOutput);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(info2)
                                .addGap(18, 18, 18)
                                .addComponent(buttonAscend)
                                .addGap(18, 18, 18)
                                .addComponent(buttonDescend))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(133, 133, 133)
                                .addComponent(sortButton))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(info1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(button10)
                                .addGap(18, 18, 18)
                                .addComponent(button100)
                                .addGap(18, 18, 18)
                                .addComponent(button1000)
                                .addGap(18, 18, 18)
                                .addComponent(button5000)))
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 376, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(122, 122, 122)
                                .addComponent(title))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(43, 43, 43)
                                .addComponent(errorLabel)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(title)
                .addGap(10, 10, 10)
                .addComponent(errorLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(info1)
                            .addComponent(button10)
                            .addComponent(button100)
                            .addComponent(button1000)
                            .addComponent(button5000))
                        .addGap(18, 18, 18)
                        .addComponent(sortButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(info2)
                            .addComponent(buttonAscend)
                            .addComponent(buttonDescend))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 312, Short.MAX_VALUE)
                            .addComponent(jScrollPane1)))
                    .addComponent(jScrollPane3))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void button10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_button10ActionPerformed
        // TODO add your handling code here:
        //I do this to all the other buttons as well, it just makes it so that when
        //you select this button, you cancel your selection on all the other buttons.
        //meaning you can only have one option selected at a time.
        button100.setSelected(false);
        button1000.setSelected(false);
        button5000.setSelected(false);
    }//GEN-LAST:event_button10ActionPerformed

    private void button100ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_button100ActionPerformed
        // TODO add your handling code here:
        button10.setSelected(false);
        button1000.setSelected(false);
        button5000.setSelected(false);
    }//GEN-LAST:event_button100ActionPerformed

    private void button1000ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_button1000ActionPerformed
        // TODO add your handling code here:
        button10.setSelected(false);
        button100.setSelected(false);
        button5000.setSelected(false);
    }//GEN-LAST:event_button1000ActionPerformed

    private void button5000ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_button5000ActionPerformed
        // TODO add your handling code here:
        button10.setSelected(false);
        button100.setSelected(false);
        button1000.setSelected(false);
    }//GEN-LAST:event_button5000ActionPerformed

    private void sortButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sortButtonActionPerformed
        // TODO add your handling code here:

        //Set the Error label to blank so that every time you run the program the
        //errors don't pile up on each other.
        errorLabel.setText("");

        //This checks to make sure the user has selected a size of the array. If
        //they haven't, tell them to.
        if (!button10.isSelected() && !button100.isSelected() && !button1000.isSelected() && !button5000.isSelected()) {
            errorLabel.setText("Please select number of objects.  ");
            sizePicked = false;
        } else {
            sizePicked = true;
        }

        //Makes sure the user has picked ascending or descending.
        //For my UI, descending is as you scroll the numbers decrease, meaning the
        //highest value is located at the top.
        if (!buttonAscend.isSelected() && !buttonDescend.isSelected()) {
            errorLabel.setText(errorLabel.getText() + "Please Select ascending or descending.");
            directionPicked = false;
        } else {
            directionPicked = true;
        }

        //Only allows the main body to run if the user chose a size and direction
        //For the array
        if (sizePicked && directionPicked) {
            //No errors if this is running so clear the error label.
            errorLabel.setText("");

            //Set the size of your array based on the option picked by the user
            if (button10.isSelected()) {
                size = 10;
            } else if (button100.isSelected()) {
                size = 100;
            } else if (button1000.isSelected()) {
                size = 1000;
            } else if (button5000.isSelected()) {
                size = 5000;
            }

            //Sets the boolean ascending true or false depending on what the user picked
            if (buttonAscend.isSelected()) {
                ascending = true;
            } else if (buttonDescend.isSelected()) {
                ascending = false;
            }

            //Set the sizes of the arrays
            origin1 = new int[size];
            origin2 = new int[size];
            origin3 = new int[size];
            s1 = new int[size];
            s2 = new int[size];
            s3 = new int[size];

            //Generate completely random numbers between -10000 and 10000 as many
            //times as the size of the array. ".toArray" makes it really easy.
            Random number = new Random();
            origin1 = number.ints(size, -10000, 10000).toArray();

            //Creates a carbon copy that isn't a reference copy, therefore the list doesn't
            //get sorted once and stay sorted, just sort the individual lists.
            for (int i = 0; i < origin1.length; i++) {
                origin2[i] = origin1[i];
                origin3[i] = origin1[i];
            }
            
            //Write to the string you set as the origin to the original output, lists a number per line
            //After it is cleared to avoid stacking previous runs.
            originOutput.setText("");
            
            for (int i : origin1) {
                originOutput.append(i + "\n");
            }

            /**
             ****Selection Sorting****
             */
            //Start the timer.
            time = System.nanoTime();
            //Reset all the counters.
            loopCounter = 0;
            compareCounter = 0;
            shiftCounter = 0;

            //Call on the selection sort method
            s1 = selectionSort(origin1);

            //Stop the timer.
            time = System.nanoTime() - time;

            //Resets the stats string because it's the first time writing to it in
            //this iteration. Avoids cluttering.
            stats = "";
            stats = "Selection Sorting Statistics"
                    + "\nNumber of Times Loop Was Run: " + loopCounter
                    + "\nNumber of Times Comparison was Made: " + compareCounter
                    + "\nNumber of Times a Value was Displaced: " + shiftCounter
                    + "\nTotal Time Taken in Milliseconds: " + Math.round(time / 1000000);

            /**
             ****Bubble Sorting****
             */
            //Start the timer
            time = System.nanoTime();
            //Reset the timers again.
            loopCounter = 0;
            compareCounter = 0;
            shiftCounter = 0;

            s2 = bubbleSort(origin2);

            //Stop the timer.
            time = System.nanoTime() - time;

            //Adds to the stats string. Write this out to the statsOutput text area
            //at the end to reduce redundancy.
            stats = stats + "\n"
                    + "\nBubble Sorting Statistics"
                    + "\nNumber of Times Loop was Run: " + loopCounter
                    + "\nNumber of Times Comparison was Made: " + compareCounter
                    + "\nNumber of Times a Value was Displaced: " + shiftCounter
                    + "\nTotal Time Taken in Milliseconds: " + Math.round(time / 1000000);

            /**
             ****Insertion Sorting****
             */
            //Starts the timer
            time = System.nanoTime();
            //Resets the counters
            loopCounter = 0;
            compareCounter = 0;
            shiftCounter = 0;

            s3 = insertionSort(origin3);

            //Stop the timer.
            time = System.nanoTime() - time;

            //Add the stats for the final method.
            stats = stats + "\n"
                    + "\nInsertion Sorting Statistics"
                    + "\nNumber of Times Loop was Run: " + loopCounter
                    + "\nNumber of Times Comparison was Made: " + compareCounter
                    + "\nNumber of Times a Value was Displaced: " + shiftCounter
                    + "\nTotal Time Taken in Milliseconds: " + Math.round(time / 1000000);

            //Finally output the stats to the statOutput.
            statOutput.setText(stats);
        }
    }//GEN-LAST:event_sortButtonActionPerformed

    private int[] selectionSort(int[] sorted) {
        //This is just the standard selection sort given to you in the content of
        //Module 15. I'll be brief.

        //i is the inital selection of the value from the array.
        for (int i = 0; i < sorted.length; i++) {
            //j is all the values that i will be compared to
            for (int j = i + 1; j < sorted.length; j++) {
                //if you find that the value is either larger or smaller and depending on your
                //direction boolean, swap the elements. Also increase the shift timer.
                if (sorted[j] < sorted[i] && ascending) {
                    shiftCounter++;
                    int temp = sorted[i];
                    sorted[i] = sorted[j];
                    sorted[j] = temp;
                } else if (sorted[j] > sorted[i] && !ascending) {
                    shiftCounter++;
                    int temp = sorted[i];
                    sorted[i] = sorted[j];
                    sorted[j] = temp;
                }
                //Increase the comparison counter
                compareCounter++;
            }
            //Increase the loop counter
            loopCounter++;
        }
        return sorted;
    }

    private int[] bubbleSort(int[] sorted) {
        //This boolean is required so that the bubble sort know when to stop sorting
        //If the while loop completes a full loop and the shifted variable is false
        //then all values are in the correct positions, stop sorting.
        shifted = true;

        //While there have been changes made to the sorted array, do this:
        while (shifted) {
            //sets shifted to false so that if the array undergoes no changes, escape the loop.
            shifted = false;
            //i is the value of the selected element in the array.
            for (int i = 0; i < sorted.length - 1; i++) {
                //If the value is less than or greater than the next value in the list
                //then, depending on your ascending boolean, move it up one element.
                //Also, increase the shift counter.
                if (sorted[i] > sorted[i + 1] && ascending) {
                    shiftCounter++;
                    shifted = true;
                    int temp = sorted[i];
                    sorted[i] = sorted[i + 1];
                    sorted[i + 1] = temp;
                } else if (sorted[i] < sorted[i + 1] && !ascending) {
                    shiftCounter++;
                    shifted = true;
                    int temp = sorted[i];
                    sorted[i] = sorted[i + 1];
                    sorted[i + 1] = temp;
                }
                //Increase the comparison counter
                compareCounter++;
            }
            //Increase the loop counter every time the while loop operates.
            loopCounter++;
        }
        return sorted;
    }

    private int[] insertionSort(int[] sorted) {
        //Standard insertion sorting method.
        //Select the next value in the list, not 0 because selecting 0 would
        //only reference itself against itself. Redundancy.
        for (int i = 1; i < sorted.length; i++) {
            //Store the value of the element you're focussed on.
            int temp = sorted[i];
            //Get the element number of the previous element in the list.
            //(The already sorted elements)
            int x = i - 1;
            //While the previous element is greater than or equal to 0 do this.
            //If the largest number referenced so far gets to the start of the list,
            //x becomes negative one which causes us problems, so prevent that.
            //I just trial and error-ed the ascending boolean in each sorting method
            //until they were arranged how I requested. Also increase the shift counter.
            //You'll notice that its x-- becaue we are referencing *previously sorted*
            //elements in the list, that's important.
            while ((x >= 0) && (sorted[x] > temp) && ascending) {
                shiftCounter++;
                sorted[x + 1] = sorted[x];
                x--;
            }
            while ((x >= 0) && (sorted[x] < temp) && !ascending) {
                shiftCounter++;
                sorted[x + 1] = sorted[x];
                x--;
            }
            //x is the value greater than your focussed value, if you have the biggest
            //value focussed, x is -1 so element 0 becomes the largest element. Sorting!
            //If you have the smallest element so far, it doesn't move from it's spot.
            sorted[x + 1] = temp;
            //Increase the comparison counter.
            compareCounter++;
        }
        //Increase the loop counter.
        loopCounter++;
        return sorted;
    }

    private void buttonAscendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonAscendActionPerformed
        // TODO add your handling code here:
        buttonDescend.setSelected(false);
    }//GEN-LAST:event_buttonAscendActionPerformed

    private void buttonDescendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonDescendActionPerformed
        // TODO add your handling code here:
        buttonAscend.setSelected(false);
    }//GEN-LAST:event_buttonDescendActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SortingRoutines().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton button10;
    private javax.swing.JRadioButton button100;
    private javax.swing.JRadioButton button1000;
    private javax.swing.JRadioButton button5000;
    private javax.swing.JRadioButton buttonAscend;
    private javax.swing.JRadioButton buttonDescend;
    private javax.swing.JLabel errorLabel;
    private javax.swing.JLabel info1;
    private javax.swing.JLabel info2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea originOutput;
    private javax.swing.JButton sortButton;
    private javax.swing.JTextArea sortedOutput;
    private javax.swing.JTextArea statOutput;
    private javax.swing.JLabel title;
    // End of variables declaration//GEN-END:variables
}
